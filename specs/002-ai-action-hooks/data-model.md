# Data Model: AI Action Hooks

**Feature**: 002-ai-action-hooks  
**Date**: 2026-01-19  
**Status**: Phase 1 Design

## Overview

This document defines the data model for the AI Action Hooks system. All entities are defined based on the feature specification and research decisions. The model supports hook registration, lifecycle event triggering, and execution tracking while maintaining the framework's git-based auditability.

## Core Entities

### 1. HookDefinition

Represents a registered hook that can execute at specific action lifecycle points.

**Attributes**:
- `id` (string, required): Unique identifier for the hook (e.g., "update_jira_status")
- `lifecycle_event` (enum, required): When the hook executes
  - Values: "before_execute" | "after_success" | "after_failure" | "after_timeout"
- `task_type_filter` (list[string], optional): Action types this hook applies to (empty = all types)
- `execution_mode` (enum, required): How the hook executes
  - Values: "sync" | "async"
  - "sync": Action waits for hook to complete (with timeout)
  - "async": Fire-and-forget, doesn't block action
- `execution_order` (integer, required): Execution priority (1 = first, higher numbers execute later)
- `enabled` (boolean, required): Whether the hook is active
- `script_path` (string, required): Path to hook script (relative to repo root)
- `config` (dict, optional): Hook-specific configuration passed to script
- `timeout_seconds` (integer, optional): Max execution time for sync hooks (default: 30)
- `retry_count` (integer, optional): Number of retry attempts on failure (default: 3)
- `retry_backoff_seconds` (integer, optional): Initial backoff delay for retries (default: 1)

**Validation Rules**:
- `id` must be unique across all hooks
- `id` must match pattern: `^[a-z0-9_]+$` (lowercase alphanumeric and underscore only)
- `script_path` must exist and be executable
- `execution_order` must be positive integer
- `timeout_seconds` must be 1-300 (5 minutes max)
- `retry_count` must be 0-10
- `retry_backoff_seconds` must be 1-60

**Storage**: `actions/hooks.yaml`

**Example**:
```yaml
hooks:
  - id: update_jira_status
    lifecycle_event: after_success
    task_type_filter: ["jira_comment", "jira_update"]
    execution_mode: async
    execution_order: 1
    enabled: true
    script_path: scripts/hooks/update_jira.py
    timeout_seconds: 30
    retry_count: 3
    retry_backoff_seconds: 2
    config:
      jira_url: https://jira.example.com
      status_field: customfield_10001
```

---

### 2. HookExecutionContext

Runtime information passed to hooks when they execute. Provides all necessary context for the hook to perform its task.

**Attributes**:
- `task_id` (string, required): Identifier of the task from task management system
- `task_type` (string, required): Type of task (matches action type)
- `action_type` (string, required): Type of action that triggered the hook
- `action_status` (enum, required): Current status of the action
  - Values: "starting" | "success" | "failure" | "timeout"
- `start_time` (datetime, required): When the action started (ISO 8601)
- `end_time` (datetime, optional): When the action ended (only for after_* events)
- `input_parameters` (dict, required): Parameters passed to the action
- `output_data` (dict, optional): Results from action execution (only for after_success)
- `error_details` (dict, optional): Error information (only for after_failure)
  - `error_type` (string): Classification of error
  - `error_message` (string): Human-readable error description
  - `stack_trace` (string, optional): Full stack trace if available
- `metadata` (dict, optional): Additional context (e.g., PR number, commit SHA, user)

**Source**: Generated by action executor at each lifecycle point

**Serialization**: JSON passed to hook script via stdin

**Example**:
```json
{
  "task_id": "TASK-123",
  "task_type": "jira_comment",
  "action_type": "jira_comment",
  "action_status": "success",
  "start_time": "2026-01-19T11:07:24Z",
  "end_time": "2026-01-19T11:07:26Z",
  "input_parameters": {
    "issue_key": "PROJ-456",
    "comment_text": "Automated comment from AI"
  },
  "output_data": {
    "comment_id": "12345",
    "comment_url": "https://jira.example.com/browse/PROJ-456?focusedCommentId=12345"
  },
  "metadata": {
    "pr_number": 42,
    "commit_sha": "abc123",
    "user": "ai-assistant"
  }
}
```

---

### 3. HookExecutionResult

Outcome of a hook execution. Returned by hook script and logged for audit trail.

**Attributes**:
- `hook_id` (string, required): ID of the hook that executed
- `execution_id` (string, required): Unique ID for this execution (UUID)
- `success` (boolean, required): Whether hook completed successfully
- `message` (string, optional): Human-readable result message
- `details` (dict, optional): Additional result data from hook script
- `duration_ms` (integer, required): Execution time in milliseconds
- `retry_attempt` (integer, required): Which retry attempt this was (0 = first attempt)
- `error` (string, optional): Error message if hook failed

**Source**: Returned by hook script via stdout (success, message, details) + measured by executor (duration_ms, retry_attempt)

**Serialization**: JSON written to log file

**Example**:
```json
{
  "hook_id": "update_jira_status",
  "execution_id": "550e8400-e29b-41d4-a716-446655440000",
  "success": true,
  "message": "Updated Jira status to Done",
  "details": {
    "old_status": "In Progress",
    "new_status": "Done",
    "transition_id": "31"
  },
  "duration_ms": 342,
  "retry_attempt": 0
}
```

---

### 4. HookExecutionLog

Audit record of a hook execution. Persisted to log file for compliance and debugging.

**Attributes**:
- `timestamp` (datetime, required): When the hook executed (ISO 8601)
- `hook_id` (string, required): ID of the hook
- `lifecycle_event` (enum, required): Which lifecycle event triggered the hook
- `task_id` (string, required): Task that was being processed
- `action_type` (string, required): Type of action
- `execution_mode` (enum, required): "sync" or "async"
- `status` (enum, required): Execution outcome
  - Values: "success" | "failure" | "timeout" | "skipped"
- `duration_ms` (integer, optional): Execution time (null if timeout)
- `retry_attempt` (integer, required): Which retry attempt (0 = first)
- `error_message` (string, optional): Error details if failed
- `execution_id` (string, required): Unique execution identifier

**Storage**: `logs/hook-executions.log` (JSON Lines format)

**Retention**: Last 1000 entries (FIFO rotation)

**Example**:
```json
{"timestamp": "2026-01-19T11:07:24Z", "hook_id": "update_jira", "lifecycle_event": "after_success", "task_id": "TASK-123", "action_type": "jira_comment", "execution_mode": "async", "status": "success", "duration_ms": 342, "retry_attempt": 0, "execution_id": "550e8400-e29b-41d4-a716-446655440000"}
```

---

### 5. Task (Reference)

Task from external task management system. Not stored by the framework, but referenced in hook context.

**Attributes** (as understood by the framework):
- `task_id` (string, required): Unique identifier in task management system
- `task_type` (string, required): Type/category of task
- `current_status` (string, optional): Current status in task management system
- `metadata` (dict, optional): Additional task properties

**Source**: Extracted from action input parameters

**Note**: The framework doesn't store tasks, it only passes task information to hooks. Task management is the responsibility of external systems.

---

## Relationships

```
HookDefinition (1) --executes--> (N) HookExecutionLog
  - One hook definition can have many execution log entries
  
HookExecutionContext (1) --produces--> (1) HookExecutionResult
  - One execution context produces one result per execution
  
HookExecutionResult (1) --recorded-as--> (1) HookExecutionLog
  - Each execution result is recorded as one log entry
  
Task (1) --triggers--> (N) HookExecutionContext
  - One task can trigger multiple hooks at different lifecycle points
```

## State Transitions

### Hook Lifecycle

```
[Registered] -> [Enabled/Disabled] -> [Executed] -> [Success/Failure/Timeout]
                     ^                                       |
                     |_______________________________________|
                              (can be toggled)
```

### Hook Execution States

```
[Queued] -> [Running] -> [Success]
                      -> [Retry] -> [Running] (up to retry_count times)
                      -> [Failure]
                      -> [Timeout]
```

## Data Flow

1. **Hook Registration**: Admin creates/updates `actions/hooks.yaml` -> HookDefinition entities loaded
2. **Action Execution**: Action completes -> Generates HookExecutionContext
3. **Hook Discovery**: Executor queries HookDefinitions matching lifecycle_event and task_type_filter
4. **Hook Execution**: Each matching hook runs with HookExecutionContext -> Produces HookExecutionResult
5. **Audit Logging**: HookExecutionResult -> Converted to HookExecutionLog -> Appended to log file

## Validation and Constraints

### Cross-Entity Constraints

- **Circular dependency prevention**: Maximum hook execution depth of 10 to prevent infinite loops
- **Execution ordering**: Hooks with same execution_order at same lifecycle_event execute in parallel
- **Timeout enforcement**: Sync hooks killed after timeout_seconds, logged as "timeout" status
- **Retry policy**: Failed hooks retry up to retry_count times with exponential backoff

### Invariants

- A disabled hook (enabled=false) will never execute
- Async hooks never block action completion
- Hook execution failures never cause action failure
- All hook executions are logged (even failures and timeouts)
- Hook script must exist and be executable before hook can be enabled

## Storage Locations

- **HookDefinition**: `actions/hooks.yaml` (version controlled)
- **HookExecutionLog**: `logs/hook-executions.log` (version controlled, size-limited)
- **HookExecutionContext**: In-memory during execution (not persisted)
- **HookExecutionResult**: In-memory during execution, logged to HookExecutionLog
- **Task**: External system (not stored in framework)

## Schema References

See `contracts/` directory for JSON Schemas:
- `hook-definition.schema.json` - Schema for hooks.yaml
- `hook-context.schema.json` - Schema for stdin to hook scripts
- `hook-result.schema.json` - Schema for stdout from hook scripts
